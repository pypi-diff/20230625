# Comparing `tmp/tsutsuji_trackcomputer-1.6.1-py3-none-any.whl.zip` & `tmp/tsutsuji_trackcomputer-1.7.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,23 +1,23 @@
-Zip file size: 58426 bytes, number of entries: 21
+Zip file size: 60727 bytes, number of entries: 21
 -rw-r--r--  2.0 unx        0 b- defN 21-Aug-22 02:52 tsutsuji/__init__.py
 -rw-r--r--  2.0 unx      647 b- defN 21-Sep-01 10:48 tsutsuji/__main__.py
--rw-r--r--  2.0 unx       22 b- defN 23-May-20 05:19 tsutsuji/_version.py
--rw-r--r--  2.0 unx    26323 b- defN 23-May-20 13:13 tsutsuji/backimg.py
+-rw-r--r--  2.0 unx       22 b- defN 23-Jun-25 03:46 tsutsuji/_version.py
+-rw-r--r--  2.0 unx    26323 b- defN 23-Jun-25 03:46 tsutsuji/backimg.py
 -rw-r--r--  2.0 unx     5514 b- defN 22-Nov-23 06:36 tsutsuji/config.py
 -rw-r--r--  2.0 unx     2155 b- defN 22-Apr-09 01:12 tsutsuji/cui2.py
 -rw-r--r--  2.0 unx     5753 b- defN 23-May-06 01:49 tsutsuji/curvetrackplot.py
--rw-r--r--  2.0 unx    17026 b- defN 22-Sep-11 03:22 tsutsuji/drawcursor.py
--rw-r--r--  2.0 unx    19787 b- defN 23-May-06 01:49 tsutsuji/gui_tsutsuji.py
+-rw-r--r--  2.0 unx    19218 b- defN 23-Jun-25 03:46 tsutsuji/drawcursor.py
+-rw-r--r--  2.0 unx    19805 b- defN 23-Jun-25 03:46 tsutsuji/gui_tsutsuji.py
 -rw-r--r--  2.0 unx     5060 b- defN 22-Sep-11 03:22 tsutsuji/kml2track.py
--rw-r--r--  2.0 unx     6311 b- defN 23-May-21 01:02 tsutsuji/kp_offset.py
+-rw-r--r--  2.0 unx     6311 b- defN 23-Jun-25 03:46 tsutsuji/kp_offset.py
 -rw-r--r--  2.0 unx    13102 b- defN 23-May-06 01:49 tsutsuji/math.py
--rw-r--r--  2.0 unx    28724 b- defN 23-May-06 01:49 tsutsuji/measure.py
+-rw-r--r--  2.0 unx    29828 b- defN 23-Jun-25 03:46 tsutsuji/measure.py
 -rw-r--r--  2.0 unx    69046 b- defN 23-May-06 01:49 tsutsuji/solver.py
--rw-r--r--  2.0 unx    35058 b- defN 23-May-21 01:45 tsutsuji/track_control.py
--rw-r--r--  2.0 unx    10318 b- defN 22-Sep-11 03:22 tsutsuji/trackwindow.py
--rw-r--r--  2.0 unx     9723 b- defN 23-May-21 02:00 tsutsuji_trackcomputer-1.6.1.dist-info/LICENSE
--rw-r--r--  2.0 unx     3468 b- defN 23-May-21 02:00 tsutsuji_trackcomputer-1.6.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-May-21 02:00 tsutsuji_trackcomputer-1.6.1.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 23-May-21 02:00 tsutsuji_trackcomputer-1.6.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     1702 b- defN 23-May-21 02:00 tsutsuji_trackcomputer-1.6.1.dist-info/RECORD
-21 files, 259840 bytes uncompressed, 55684 bytes compressed:  78.6%
+-rw-r--r--  2.0 unx    45810 b- defN 23-Jun-25 03:46 tsutsuji/track_control.py
+-rw-r--r--  2.0 unx    13273 b- defN 23-Jun-25 03:51 tsutsuji/trackwindow.py
+-rw-r--r--  2.0 unx     9723 b- defN 23-Jun-25 04:19 tsutsuji_trackcomputer-1.7.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     3468 b- defN 23-Jun-25 04:19 tsutsuji_trackcomputer-1.7.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Jun-25 04:19 tsutsuji_trackcomputer-1.7.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 23-Jun-25 04:19 tsutsuji_trackcomputer-1.7.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1702 b- defN 23-Jun-25 04:19 tsutsuji_trackcomputer-1.7.0.dist-info/RECORD
+21 files, 276861 bytes uncompressed, 57985 bytes compressed:  79.1%
```

## zipnote {}

```diff
@@ -42,23 +42,23 @@
 
 Filename: tsutsuji/track_control.py
 Comment: 
 
 Filename: tsutsuji/trackwindow.py
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.6.1.dist-info/LICENSE
+Filename: tsutsuji_trackcomputer-1.7.0.dist-info/LICENSE
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.6.1.dist-info/METADATA
+Filename: tsutsuji_trackcomputer-1.7.0.dist-info/METADATA
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.6.1.dist-info/WHEEL
+Filename: tsutsuji_trackcomputer-1.7.0.dist-info/WHEEL
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.6.1.dist-info/top_level.txt
+Filename: tsutsuji_trackcomputer-1.7.0.dist-info/top_level.txt
 Comment: 
 
-Filename: tsutsuji_trackcomputer-1.6.1.dist-info/RECORD
+Filename: tsutsuji_trackcomputer-1.7.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## tsutsuji/_version.py

```diff
@@ -1 +1 @@
-__version__ = '1.6.1'
+__version__ = '1.7.0'
```

## tsutsuji/drawcursor.py

```diff
@@ -16,14 +16,16 @@
 
 '''
 '''
 
 import numpy as np
 from . import math
 import tkinter as tk
+import re
+
 from kobushi import dialog_multifields
 
 class cursor():
     def __init__(self,parent):
         self.p = parent
     def point_and_dir(self):
         def click_1st(event):
@@ -92,14 +94,18 @@
 
         self.setmarkerobj()
         self.prev_trackpos = None
     def start(self):
         self.track_key = self.p.values[3].get()
         if self.track_key != '@absolute':
             self.track_data = self.p.parent.mainwindow.trackcontrol.track[self.track_key]['result'][:,1:3]
+        elif '@OWOT_' in self.track_key:
+            parent_tr = re.search('(?<=@OWOT_).+(?=@)',self.track_key).group(0)
+            child_tr =  self.track_key.split('@_')[-1]
+            self.track_data = self.p.parent.mainwindow.trackcontrol.track[parent_tr]['othertrack'][child_tr]['result'][:,1:3]
         else:
             self.track_data = None
 
         self.press_id = self.canvas.mpl_connect('button_press_event',self.press)
         self.move_id = self.canvas.mpl_connect('motion_notify_event',self.move)
     def setpos(self,x,y):
         self.markerpos.set_data(x,y)
@@ -126,15 +132,20 @@
             self.prev_trackpos = result
         self.canvas.mpl_disconnect(self.press_id)
         self.canvas.mpl_disconnect(self.move_id)
     def nearestpoint(self,x,y):
         inputpos = np.array([x,y])
         distance = (self.track_data - inputpos)**2
         min_dist_ix = np.argmin(np.sqrt(distance[:,0]+distance[:,1]))
-        return self.p.parent.mainwindow.trackcontrol.track[self.track_key]['result'][min_dist_ix]
+        if '@OWOT_' in self.track_key:
+            parent_tr = re.search('(?<=@OWOT_).+(?=@)',self.track_key).group(0)
+            child_tr =  self.track_key.split('@_')[-1]
+            return self.p.parent.mainwindow.trackcontrol.track[parent_tr]['othertrack'][child_tr]['result'][min_dist_ix]
+        else:
+            return self.p.parent.mainwindow.trackcontrol.track[self.track_key]['result'][min_dist_ix]
     def setmarkerobj(self,pos=False):
         self.markerpos, = self.ax.plot([],[],self.color+'x')
         if pos:
             self.markerpos.set_data(self.p.values[0].get(),self.p.values[1].get())
         
 class arrow():
     def __init__(self,parent,marker):
@@ -179,15 +190,15 @@
                 self.settangent(position)
             self.canvas.draw()
 
             sin = vector[1]/np.sqrt(vector[0]**2+vector[1]**2)
             cos = vector[0]/np.sqrt(vector[0]**2+vector[1]**2)
             theta = np.arccos(cos) if sin > 0 else -np.arccos(cos)
             self.p.values[2].set(np.rad2deg(theta))
-            self.p.values_toshow[2].set('{:.1f}'.format(np.rad2deg(theta)))
+            self.p.values_toshow[2].set('{:.3f}'.format(np.rad2deg(theta)))
             self.p.parent.setdistance()
     def press(self,event):
         self.p.parent.printdirection(mycursor=self.p)
         self.p.parent.sendtopmost()
         self.canvas.mpl_disconnect(self.press_id)
         self.canvas.mpl_disconnect(self.move_id)
     def setobj(self,element,reset=False):
@@ -268,14 +279,18 @@
         self.markerobj = marker_simple(self.p,self.ax,self.canvas,self.color,self.p.parentwindow.sendtopmost,self.p.parent.sendtopmost)
         self.markerobj.posfunc = lambda x,y:self.posfunc(x,y)
         self.markerobj.pressfunc = lambda p:self.pressfunc(p)
     def start(self):
         self.track_key = self.p.values[3].get()
         if '@' not in self.track_key:
             self.track_data = self.p.parent.mainwindow.trackcontrol.track[self.track_key]['result'][:,1:3]
+        elif '@OT_' in self.track_key:
+            parent_tr = re.search('(?<=@OT_).+(?=@)',self.track_key).group(0)
+            child_tr =  self.track_key.split('@_')[-1]
+            self.track_data = self.p.parent.mainwindow.trackcontrol.track[parent_tr]['othertrack'][child_tr]['result'][:,1:3]
         elif '@KML_' in self.track_key or '@CSV_' in self.track_key:
             self.track_data = self.p.parent.mainwindow.trackcontrol.pointsequence_track.track[self.track_key]['result'][:,1:3]
         else:
             self.track_data = None
         self.markerobj.start(lambda x,y:self.posfunc(x,y),lambda p:self.pressfunc(p))
     def move(self,event):
         self.markerobj.move(event)
@@ -283,14 +298,18 @@
         self.markerobj.press(event)
     def nearestpoint(self,x,y):
         inputpos = np.array([x,y])
         distance = (self.track_data - inputpos)**2
         min_dist_ix = np.argmin(np.sqrt(distance[:,0]+distance[:,1]))
         if '@' not in self.track_key:
             result = self.p.parent.mainwindow.trackcontrol.track[self.track_key]['result'][min_dist_ix]
+        elif '@OT_' in self.track_key:
+            parent_tr = re.search('(?<=@OT_).+(?=@)',self.track_key).group(0)
+            child_tr =  self.track_key.split('@_')[-1]
+            result = self.p.parent.mainwindow.trackcontrol.track[parent_tr]['othertrack'][child_tr]['result'][min_dist_ix]
         else:
             result = self.p.parent.mainwindow.trackcontrol.pointsequence_track.track[self.track_key]['result'][min_dist_ix]
         return result
     def setmarkerobj(self,pos=False):
         self.markerobj.setobj()
         if pos:
             #self.markerobj.setpos(self.p.values[0].get(),self.p.values[1].get())
@@ -303,19 +322,19 @@
         else:
             result = self.nearestpoint(xpos,ypos)
             x = result[1]
             y = result[2]
             kp = result[0]
         self.p.values[0].set(x)
         self.p.values[1].set(y)
-        self.p.values_toshow[0].set('{:.1f}'.format(x))
-        self.p.values_toshow[1].set('{:.1f}'.format(y))
+        self.p.values_toshow[0].set('{:.3f}'.format(x))
+        self.p.values_toshow[1].set('{:.3f}'.format(y))
         if kp is not None:
             self.p.values[4].set(kp)
-            self.p.values_toshow[4].set('{:.1f}'.format(kp))
+            self.p.values_toshow[4].set('{:.3f}'.format(kp))
         self.p.parent.setdistance()
         return x,y
     def pressfunc(self,parent):
         self.p.parent.printdistance(mycursor=self.p)
         if self.track_key != '@absolute':
             self.prev_trackpos = self.nearestpoint(self.markerobj.xout,self.markerobj.yout)
     def set_direct(self,replot=False):
@@ -323,21 +342,29 @@
         if self.track_key == '@absolute':
             self.track_data = None
             kp = None
         else:
             kp = self.p.values[4].get()
             if '@' not in self.track_key:
                 self.track_data = self.p.parent.mainwindow.trackcontrol.track[self.track_key]['result']
+            elif '@OT_' in self.track_key:
+                parent_tr = re.search('(?<=@OT_).+(?=@)',self.track_key).group(0)
+                child_tr =  self.track_key.split('@_')[-1]
+                self.track_data = self.p.parent.mainwindow.trackcontrol.track[parent_tr]['othertrack'][child_tr]['result']
             else:
                 self.track_data = self.p.parent.mainwindow.trackcontrol.pointsequence_track.track[self.track_key]['result']
 
             pos_kp = []
             for i in range(0,5):
                 if '@' not in self.track_key:
                     pos_kp.append(math.interpolate_with_dist(self.p.parent.mainwindow.trackcontrol.track[self.track_key]['result'],i,kp))
+                elif '@OT_' in self.track_key:
+                    parent_tr = re.search('(?<=@OT_).+(?=@)',self.track_key).group(0)
+                    child_tr =  self.track_key.split('@_')[-1]
+                    pos_kp.append(math.interpolate_with_dist(self.p.parent.mainwindow.trackcontrol.track[parent_tr]['othertrack'][child_tr]['result'],i,kp))
                 else:
                     pos_kp.append(math.interpolate_with_dist(self.p.parent.mainwindow.trackcontrol.pointsequence_track.track[self.track_key]['result'],i,kp))
             #pos_kp = self.track_data[self.track_data[:,0] == kp][-1]
            
             if self.p.coordinate_v.get() == 'abs':
                 offset = np.array([0,0])
                 offs_angle = 0 
@@ -358,14 +385,18 @@
 
             self.p.values[2].set(np.rad2deg(pos_kp[4]+offs_angle))
             self.p.values_toshow[2].set('{:.1f}'.format(np.rad2deg(pos_kp[4]+offs_angle)))
 
             self.prev_trackpos = pos_kp
             if '@' not in self.track_key:
                 self.track_data = self.p.parent.mainwindow.trackcontrol.track[self.track_key]['result'][:1,3]
+            elif '@OT_' in self.track_key:
+                parent_tr = re.search('(?<=@OT_).+(?=@)',self.track_key).group(0)
+                child_tr =  self.track_key.split('@_')[-1]
+                self.track_data = self.p.parent.mainwindow.trackcontrol.track[parent_tr]['othertrack'][child_tr]['result'][:1,3]
             else:
                 self.track_data = self.p.parent.mainwindow.trackcontrol.pointsequence_track.track[self.track_key]['result'][:1,3]
 
             if self.p.coordinate_v.get() != 'abs':
                 self.track_key = '@absolute'
                 self.p.values[3].set('@absolute')
                 self.p.coordinate_v.set('abs')
```

## tsutsuji/gui_tsutsuji.py

```diff
@@ -97,28 +97,28 @@
         
         self.fig_plane = plt.figure(figsize=(9,7),tight_layout=True)
         gs1 = self.fig_plane.add_gridspec(nrows=1,ncols=1)
         self.ax_plane = self.fig_plane.add_subplot(gs1[0])
         
         self.plt_canvas_base = tk.Canvas(self.canvas_frame, bg="white", width=900, height=700)
         self.plt_canvas_base.grid(row = 0, column = 0)
-        
+
         def on_canvas_resize(event):
-            self.plt_canvas_base.itemconfigure(self.fig_frame_id, width=event.width, height=event.height)
             #print(event)
+            self.plt_canvas_base.itemconfigure(self.fig_frame_id, width=event.width, height=event.height)
         
         self.fig_frame = tk.Frame(self.plt_canvas_base)
         self.fig_frame_id = self.plt_canvas_base.create_window((0, 0), window=self.fig_frame, anchor="nw")
         self.fig_frame.columnconfigure(0, weight=1)
         self.fig_frame.rowconfigure(0, weight=1)
         self.plt_canvas_base.bind("<Configure>", on_canvas_resize)
         
         self.fig_canvas = FigureCanvasTkAgg(self.fig_plane, master=self.fig_frame)
         self.fig_canvas.draw()
-        self.fig_canvas.get_tk_widget().grid(row=0, column=0, sticky='news')
+        self.fig_canvas.get_tk_widget().grid(row=0, column=0, sticky=(tk.N, tk.W, tk.E, tk.S))
         
         self.canvas_frame.columnconfigure(0, weight=1)
         #self.canvas_frame.columnconfigure(1, weight=1)
         self.canvas_frame.rowconfigure(0, weight=1)
         #self.canvas_frame.rowconfigure(1, weight=1)
         
         #ボタンフレーム
@@ -181,15 +181,15 @@
 
         # ---
 
         self.plotarea_symbol_frame = ttk.Labelframe(self.plotarea_frame, padding='3 3 3 3', text = 'Symbols')
         self.plotarea_symbol_frame.grid(column=0, row=2, sticky=(tk.E,tk.W))
         self.plot_marker_ctrl = {}
         position = 0
-        for val in ['radius','gradient','supplemental_cp']:
+        for val in ['radius','gradient','supplemental_cp','track']:
             self.plot_marker_ctrl[val] = {}
             self.plot_marker_ctrl[val]['variable'] = tk.BooleanVar(value=False)
             self.plot_marker_ctrl[val]['widget'] = ttk.Checkbutton(self.plotarea_symbol_frame, text=val, variable=self.plot_marker_ctrl[val]['variable'], onvalue=True, offvalue=False)
             self.plot_marker_ctrl[val]['widget'].grid(column=0, row=position, sticky=(tk.E,tk.W))
             position +=1
 
         # ---
```

## tsutsuji/measure.py

```diff
@@ -17,14 +17,15 @@
 '''
 '''
 
 import matplotlib.pyplot as plt
 import numpy as np
 import tkinter as tk
 from tkinter import ttk
+import re
 
 from kobushi import trackcoordinate
 
 from . import drawcursor
 from . import solver
 from . import math
 from . import curvetrackplot
@@ -44,19 +45,19 @@
             self.name_l = ttk.Label(self.pframe, text=self.name)
             self.name_l.grid(column=0, row=row, sticky=(tk.E,tk.W))
             
             self.values = [tk.DoubleVar(value=0),tk.DoubleVar(value=0),tk.DoubleVar(value=0),tk.StringVar(value=''),tk.DoubleVar(value=0)]
             self.values_toshow = [tk.StringVar(value='0'),tk.StringVar(value='0'),tk.StringVar(value='0'),tk.StringVar(value=''),tk.StringVar(value='0')]
             self.coordinate_v = tk.StringVar(value='abs')
             
-            self.x_e = ttk.Entry(self.pframe, textvariable=self.values_toshow[0],width=5)
-            self.y_e = ttk.Entry(self.pframe, textvariable=self.values_toshow[1],width=5)
-            self.theta_e = ttk.Entry(self.pframe, textvariable=self.values_toshow[2],width=5)
-            self.track_e = ttk.Combobox(self.pframe, textvariable=self.values[3],width=9)
-            self.trackkp_e = ttk.Entry(self.pframe, textvariable=self.values_toshow[4],width=5)
+            self.x_e = ttk.Entry(self.pframe, textvariable=self.values_toshow[0],width=6)
+            self.y_e = ttk.Entry(self.pframe, textvariable=self.values_toshow[1],width=6)
+            self.theta_e = ttk.Entry(self.pframe, textvariable=self.values_toshow[2],width=6)
+            self.track_e = ttk.Combobox(self.pframe, textvariable=self.values[3],width=18)
+            self.trackkp_e = ttk.Entry(self.pframe, textvariable=self.values_toshow[4],width=6)
             
             self.make_trackkeylist()
             self.values[3].set('@absolute')
             self.track_e.state(["readonly"])
             
             self.setcursor_b = ttk.Button(self.pframe, text="Pos.", command=self.marker.start, width=4)
             self.setcursor_dir_b = ttk.Button(self.pframe, text="Dir.", command=self.arrow.start, width=4)
@@ -80,17 +81,25 @@
         def setmarkerpos_fromkeyboard(self):
             for i in [0,1,2,4]:
                 self.values[i].set(float(self.values_toshow[i].get()))
             self.marker.set_direct()
             self.arrow.set_direct()
         def make_trackkeylist(self):
             currentval = self.values[3].get()
+
+            owot_keys = []
+            for parent_tr in self.parent.mainwindow.trackcontrol.track.keys():
+                for child_tr in self.parent.mainwindow.trackcontrol.track[parent_tr]['othertrack'].keys():
+                    owot_keys.append('@OT_{:s}@_{:s}'.format(parent_tr,child_tr))
+                
             self.track_e['values'] = tuple(['@absolute'])\
                 +tuple(self.parent.mainwindow.trackcontrol.track.keys())\
-                +tuple(self.parent.mainwindow.trackcontrol.pointsequence_track.track.keys())
+                +tuple(self.parent.mainwindow.trackcontrol.pointsequence_track.track.keys())\
+                +tuple(owot_keys)
+            
             if currentval not in self.track_e['values']:
                 self.values[3].set('@absolute')
     def __init__(self,mainwindow):
         self.mainwindow = mainwindow
         self.master = None
     def create_widgets(self):
         if self.master == None:
@@ -154,17 +163,16 @@
             # 直交軌道探索フレーム
             self.nearesttrack_f = ttk.Frame(self.mainframe, padding='3 3 3 3')
             self.nearesttrack_f.grid(column=0, row=4, sticky=(tk.N, tk.W, tk.E, tk.S))
 
             self.nearesttrack_sel_l = ttk.Label(self.nearesttrack_f, text='Track')
             self.nearesttrack_sel_l.grid(column=2, row=0, sticky=(tk.E,tk.W))
             self.nearesttrack_sel_v = tk.StringVar(value='')
-            self.nearesttrack_sel_e = ttk.Combobox(self.nearesttrack_f, textvariable=self.nearesttrack_sel_v,width=8)
-            self.nearesttrack_sel_e['values'] = tuple(self.mainwindow.trackcontrol.track.keys())\
-                +tuple(self.mainwindow.trackcontrol.pointsequence_track.track.keys())
+            self.nearesttrack_sel_e = ttk.Combobox(self.nearesttrack_f, textvariable=self.nearesttrack_sel_v,width=18)
+            self.nearesttrack_sel_e['values'] = self.reload_nearesttrack_keys()
             self.nearesttrack_sel_e.grid(column=3, row=0, sticky=(tk.E,tk.W))
             self.nearesttrack_sel_e.state(["readonly"])
             
             self.nearesttrack_cursor_l = ttk.Label(self.nearesttrack_f, text='Cursor')
             self.nearesttrack_cursor_l.grid(column=0, row=0, sticky=(tk.E,tk.W))
             self.nearesttrack_cursor_v = tk.StringVar(value='A')
             self.nearesttrack_cursor_e = ttk.Combobox(self.nearesttrack_f, textvariable=self.nearesttrack_cursor_v,width=4)
@@ -439,14 +447,18 @@
         cursor = self.nearesttrack_cursor_v.get()
         cursor_obj = {'A':self.cursor_A, 'B':self.cursor_B, 'C':self.cursor_C, 'D':self.cursor_D}
         
         inputpos = np.array([cursor_obj[cursor].values[0].get(),cursor_obj[cursor].values[1].get()])
         trackkey = self.nearesttrack_sel_v.get()
         if '@' not in trackkey:
             track = self.mainwindow.trackcontrol.track[trackkey]['result']
+        elif '@OT_' in trackkey:
+            parent_tr = re.search('(?<=@OT_).+(?=@)',trackkey).group(0)
+            child_tr =  trackkey.split('@_')[-1]
+            track = self.mainwindow.trackcontrol.track[parent_tr]['othertrack'][child_tr]['result']
         else:
             track = self.mainwindow.trackcontrol.pointsequence_track.track[trackkey]['result']
         track_pos = track[:,1:3]
 
         result = math.minimumdist(track_pos, inputpos)
         kilopost = math.cross_kilopost(track, result)
             
@@ -520,8 +532,18 @@
                 marker.values[i].set(float(marker.values_toshow[i].get()))
             marker.marker.set_direct()
             marker.arrow.set_direct()
     def reload_trackkeys(self):
         if self.master is not None:
             for marker in [self.cursor_A, self.cursor_B, self.cursor_C, self.cursor_D]:
                 marker.make_trackkeylist()
-                
+            self.nearesttrack_sel_e['values']=self.reload_nearesttrack_keys()
+    def reload_nearesttrack_keys(self,target=None):
+        owot_keys = []
+        for parent_tr in self.mainwindow.trackcontrol.track.keys():
+            for child_tr in self.mainwindow.trackcontrol.track[parent_tr]['othertrack'].keys():
+                owot_keys.append('@OT_{:s}@_{:s}'.format(parent_tr,child_tr))
+
+        result = tuple(self.mainwindow.trackcontrol.track.keys())\
+            +tuple(self.mainwindow.trackcontrol.pointsequence_track.track.keys())\
+            +tuple(owot_keys)
+        return result
```

## tsutsuji/track_control.py

```diff
@@ -18,14 +18,15 @@
 '''
 
 import os
 import pathlib
 import matplotlib.pyplot as plt
 import numpy as np
 from scipy import interpolate
+import re
 
 from kobushi import mapinterpreter
 from kobushi import trackgenerator
 
 from . import config
 from . import math
 from . import kml2track
@@ -48,16 +49,17 @@
         self.conf = config.Config(path)
         self.path = path
     def loadmap(self,to_load=None):
         '''mapファイルの読み込みと座標データ生成
 
         '''
 
-        #import pdb
-        #pdb.set_trace()
+        if False:
+            import pdb
+            pdb.set_trace()
         
         if self.conf != None:
             self.track = {}
             self.rel_track = {}
             self.rel_track_radius = {}
             self.rel_track_radius_cp = {}
             self.generated_othertrack = None
@@ -102,98 +104,209 @@
                                                                     z0 = self.conf.track_data[i]['y'] + pos_origin_abs[3],\
                                                                     theta0 = np.deg2rad(self.conf.track_data[i]['angle']) + pos_origin_abs[4])
                 self.track[i]['result'] = self.track[i]['tgen'].generate_owntrack()
                 self.track[i]['cplist_symbol'] = self.take_cp_by_types(self.track[i]['data'].own_track.data)
                 self.track[i]['toshow'] = True
                 self.track[i]['output_mapfile'] = None
 
+                # 従属する他軌道座標データを生成
+                self.track[i]['data'].owntrack_pos = self.track[i]['result']
+                self.track[i]['data'].owntrack_curve = self.track[i]['tgen'].generate_curveradius_dist()
+
+                self.track[i]['othertrack'] = {}
+                for otkey in self.track[i]['data'].othertrack.data.keys():
+                    self.track[i]['othertrack'][otkey] = {}
+                    otdata = self.track[i]['othertrack'][otkey]
+                    otdata['tgen'] = trackgenerator.OtherTrackGenerator(self.track[i]['data'],otkey)
+                    otdata['toshow'] = True
+                    otdata['color'] = self.conf.track_data[i]['color']#.copy()
+
+                    result_tmp = otdata['tgen'].generate()
+                    result_theta = []
+                    ix = 0
+                    while ix<len(result_tmp)-1: # 生成した座標データに方位情報を追加する
+                        data = result_tmp[ix]
+                        result_theta.append([data[0],\
+                                             data[1],\
+                                             data[2],\
+                                             data[3],\
+                                             np.arctan((result_tmp[ix+1][2]-result_tmp[ix][2])/((result_tmp[ix+1][1]-result_tmp[ix][1]))),\
+                                             0,\
+                                             0,\
+                                             data[4],\
+                                             data[5],\
+                                             data[6],\
+                                             data[7]])
+                        # [距離程, x, y, z, theta, radius(=0), gradient(=0), interpolate_func, cant, center, gauge]
+                        ix +=1
+                    data = result_tmp[ix]
+                    result_theta.append([data[0],\
+                                         data[1],\
+                                         data[2],\
+                                         data[3],\
+                                         result_tmp[ix-1][4],\
+                                         0,\
+                                         0,\
+                                         data[4],\
+                                         data[5],\
+                                         data[6],\
+                                         data[7]])
+                    otdata['result'] = np.array(result_theta)
+
         self.pointsequence_track.load_files(self.conf)
             
             
-    def relativepoint_single(self,to_calc,owntrack=None):
+    def relativepoint_single(self,to_calc,owntrack=None,parent_track=None):
         '''owntrackを基準とした相対座標への変換
 
         Args:
              string
                  to_calc: 変換する軌道
              string
                  owntrack: 自軌道 (Option)
         Return:
              ndarray
                  [[owntrack基準の距離程, 変換後x座標成分(=0), 変換後y座標成分, 変換後z座標成分, 対応する軌道の距離程,絶対座標x成分,絶対座標y成分,絶対座標z成分,カント], ...]
         '''
         def interpolate(aroundzero,ix,typ,base='x_tr'):
             return (aroundzero[typ][ix+1]-aroundzero[typ][ix])/(aroundzero[base][ix+1]-aroundzero[base][ix])*(-aroundzero[base][ix])+aroundzero[typ][ix]
+        def take_relpos_std(src,tgt):
+            len_tr = len(tgt)
+            result = []
+            # 自軌道に対する相対座標の算出
+            for pos in src:
+                tgt_xy = np.vstack((tgt[:,1],tgt[:,2]))
+                tgt_xy_trans = np.dot(math.rotate(-pos[4]),(tgt_xy - np.vstack((pos[1],pos[2])) ) ) # 自軌道注目点を原点として座標変換
+                min_ix = np.where(np.abs(tgt_xy_trans[0])==min(np.abs(tgt_xy_trans[0]))) # 変換後の座標でx'成分絶対値が最小となる点(=y'軸との交点)のインデックスを求める
+                min_ix_val = min_ix[0][0]
+
+                if min_ix_val > 0 and min_ix_val < len_tr-1: # y'軸との最近接点が軌道区間内にある場合
+                    aroundzero = {'x_tr':tgt_xy_trans[0][min_ix_val-1:min_ix_val+2],\
+                                  'y_tr':tgt_xy_trans[1][min_ix_val-1:min_ix_val+2],\
+                                  'kp':  tgt[:,0][min_ix_val-1:min_ix_val+2],\
+                                  'x_ab':tgt[:,1][min_ix_val-1:min_ix_val+2],\
+                                  'y_ab':tgt[:,2][min_ix_val-1:min_ix_val+2],\
+                                  'z_ab':tgt[:,3][min_ix_val-1:min_ix_val+2],\
+                                  'cant':tgt[:,8][min_ix_val-1:min_ix_val+2]}
+                    # aroundzero : [変換後x座標成分, 変換後y座標成分, 対応する軌道の距離程, 絶対座標x成分, 絶対座標y成分]
+                    signx = np.sign(aroundzero['x_tr'])
+                    if signx[0] != signx[1]:
+                        result.append([pos[0],\
+                                       0,\
+                                       interpolate(aroundzero,0,'y_tr'),\
+                                       interpolate(aroundzero,0,'z_ab') - pos[3],\
+                                       interpolate(aroundzero,0,'kp'),\
+                                       interpolate(aroundzero,0,'x_ab'),\
+                                       interpolate(aroundzero,0,'y_ab'),\
+                                       interpolate(aroundzero,0,'z_ab'),\
+                                       interpolate(aroundzero,0,'cant')])
+                    elif signx[1] != signx[2]:
+                        result.append([pos[0],\
+                                       0,\
+                                       interpolate(aroundzero,1,'y_tr'),\
+                                       interpolate(aroundzero,1,'z_ab') - pos[3],\
+                                       interpolate(aroundzero,1,'kp'),\
+                                       interpolate(aroundzero,1,'x_ab'),\
+                                       interpolate(aroundzero,1,'y_ab'),\
+                                       interpolate(aroundzero,1,'z_ab'),\
+                                       interpolate(aroundzero,1,'cant')])
+                else:
+                    result.append([pos[0],\
+                                   tgt_xy_trans[0][min_ix][0],\
+                                   tgt_xy_trans[1][min_ix][0],\
+                                   tgt[:,3][min_ix][0] - pos[3],\
+                                   tgt[:,0][min_ix][0],\
+                                   tgt[:,1][min_ix][0],\
+                                   tgt[:,2][min_ix][0],\
+                                   tgt[:,3][min_ix][0],\
+                                   tgt[:,8][min_ix][0]]) # y'軸との交点での自軌道距離程、x'成分(0になるべき)、y'成分(相対距離)を出力
+            return result
+        def take_relpos_owot(src,tgt):
+            len_tr = len(tgt)
+            result = []
+            # 自軌道に対する相対座標の算出
+            for pos in src:
+                tgt_xy = np.vstack((tgt[:,1],tgt[:,2]))
+                tgt_xy_trans = np.dot(math.rotate(-pos[4]),(tgt_xy - np.vstack((pos[1],pos[2])) ) ) # 自軌道注目点を原点として座標変換
+                min_ix = np.where(np.abs(tgt_xy_trans[0])==min(np.abs(tgt_xy_trans[0]))) # 変換後の座標でx'成分絶対値が最小となる点(=y'軸との交点)のインデックスを求める
+                min_ix_val = min_ix[0][0]
+
+                if min_ix_val > 0 and min_ix_val < len_tr-1: # y'軸との最近接点が軌道区間内にある場合
+                    aroundzero = {'x_tr':tgt_xy_trans[0][min_ix_val-1:min_ix_val+2],\
+                                  'y_tr':tgt_xy_trans[1][min_ix_val-1:min_ix_val+2],\
+                                  'kp':  tgt[:,0][min_ix_val-1:min_ix_val+2],\
+                                  'x_ab':tgt[:,1][min_ix_val-1:min_ix_val+2],\
+                                  'y_ab':tgt[:,2][min_ix_val-1:min_ix_val+2],\
+                                  'z_ab':tgt[:,3][min_ix_val-1:min_ix_val+2],\
+                                  'cant':tgt[:,8][min_ix_val-1:min_ix_val+2]}
+                    # aroundzero : [変換後x座標成分, 変換後y座標成分, 対応する軌道の距離程, 絶対座標x成分, 絶対座標y成分]
+                    signx = np.sign(aroundzero['x_tr'])
+                    if signx[0] != signx[1]:
+                        result.append([pos[0],\
+                                       0,\
+                                       interpolate(aroundzero,0,'y_tr'),\
+                                       interpolate(aroundzero,0,'z_ab') - pos[3],\
+                                       interpolate(aroundzero,0,'kp'),\
+                                       interpolate(aroundzero,0,'x_ab'),\
+                                       interpolate(aroundzero,0,'y_ab'),\
+                                       interpolate(aroundzero,0,'z_ab'),\
+                                       interpolate(aroundzero,0,'cant')])
+                    elif signx[1] != signx[2]:
+                        result.append([pos[0],\
+                                       0,\
+                                       interpolate(aroundzero,1,'y_tr'),\
+                                       interpolate(aroundzero,1,'z_ab') - pos[3],\
+                                       interpolate(aroundzero,1,'kp'),\
+                                       interpolate(aroundzero,1,'x_ab'),\
+                                       interpolate(aroundzero,1,'y_ab'),\
+                                       interpolate(aroundzero,1,'z_ab'),\
+                                       interpolate(aroundzero,1,'cant')])
+                else:
+                    result.append([pos[0],\
+                                   tgt_xy_trans[0][min_ix][0],\
+                                   tgt_xy_trans[1][min_ix][0],\
+                                   tgt[:,3][min_ix][0] - pos[3],\
+                                   tgt[:,0][min_ix][0],\
+                                   tgt[:,1][min_ix][0],\
+                                   tgt[:,2][min_ix][0],\
+                                   tgt[:,3][min_ix][0],\
+                                   tgt[:,8][min_ix][0]]) # y'軸との交点での自軌道距離程、x'成分(0になるべき)、y'成分(相対距離)を出力
+            return result
+        
         owntrack = self.conf.owntrack if owntrack == None else owntrack
-        if '@' not in to_calc:
+        src = self.track[owntrack]['result']
+        if parent_track is not None:
+            tgt = self.track[parent_track]['othertrack'][to_calc]['result']
+            result = take_relpos_owot(src,tgt)
+        elif '@' not in to_calc:
             tgt = self.track[to_calc]['result']
+            result = take_relpos_std(src,tgt)
         else:
             tgt = self.pointsequence_track.track[to_calc]['result']
-        src = self.track[owntrack]['result']
-        len_tr = len(tgt)
-        result = []
-        # 自軌道に対する相対座標の算出
-        for pos in src:
-            tgt_xy = np.vstack((tgt[:,1],tgt[:,2]))
-            tgt_xy_trans = np.dot(math.rotate(-pos[4]),(tgt_xy - np.vstack((pos[1],pos[2])) ) ) # 自軌道注目点を原点として座標変換
-            min_ix = np.where(np.abs(tgt_xy_trans[0])==min(np.abs(tgt_xy_trans[0]))) # 変換後の座標でx'成分絶対値が最小となる点(=y'軸との交点)のインデックスを求める
-            min_ix_val = min_ix[0][0]
-
-            if min_ix_val > 0 and min_ix_val < len_tr-1: # y'軸との最近接点が軌道区間内にある場合
-                aroundzero = {'x_tr':tgt_xy_trans[0][min_ix_val-1:min_ix_val+2],\
-                              'y_tr':tgt_xy_trans[1][min_ix_val-1:min_ix_val+2],\
-                              'kp':  tgt[:,0][min_ix_val-1:min_ix_val+2],\
-                              'x_ab':tgt[:,1][min_ix_val-1:min_ix_val+2],\
-                              'y_ab':tgt[:,2][min_ix_val-1:min_ix_val+2],\
-                              'z_ab':tgt[:,3][min_ix_val-1:min_ix_val+2],\
-                              'cant':tgt[:,8][min_ix_val-1:min_ix_val+2]}
-                # aroundzero : [変換後x座標成分, 変換後y座標成分, 対応する軌道の距離程, 絶対座標x成分, 絶対座標y成分]
-                signx = np.sign(aroundzero['x_tr'])
-                if signx[0] != signx[1]:
-                    result.append([pos[0],\
-                                   0,\
-                                   interpolate(aroundzero,0,'y_tr'),\
-                                   interpolate(aroundzero,0,'z_ab') - pos[3],\
-                                   interpolate(aroundzero,0,'kp'),\
-                                   interpolate(aroundzero,0,'x_ab'),\
-                                   interpolate(aroundzero,0,'y_ab'),\
-                                   interpolate(aroundzero,0,'z_ab'),\
-                                   interpolate(aroundzero,0,'cant')])
-                elif signx[1] != signx[2]:
-                    result.append([pos[0],\
-                                   0,\
-                                   interpolate(aroundzero,1,'y_tr'),\
-                                   interpolate(aroundzero,1,'z_ab') - pos[3],\
-                                   interpolate(aroundzero,1,'kp'),\
-                                   interpolate(aroundzero,1,'x_ab'),\
-                                   interpolate(aroundzero,1,'y_ab'),\
-                                   interpolate(aroundzero,1,'z_ab'),\
-                                   interpolate(aroundzero,1,'cant')])
-            else:
-                result.append([pos[0],\
-                               tgt_xy_trans[0][min_ix][0],\
-                               tgt_xy_trans[1][min_ix][0],\
-                               tgt[:,3][min_ix][0] - pos[3],\
-                               tgt[:,0][min_ix][0],\
-                               tgt[:,1][min_ix][0],\
-                               tgt[:,2][min_ix][0],\
-                               tgt[:,3][min_ix][0],\
-                               tgt[:,8][min_ix][0]]) # y'軸との交点での自軌道距離程、x'成分(0になるべき)、y'成分(相対距離)を出力
+            result = take_relpos_std(src,tgt)
         return(np.array(result))
     def relativepoint_all(self,owntrack=None):
         '''読み込んだ全ての軌道についてowntrackを基準とした相対座標への変換。
 
         '''
         owntrack = self.conf.owntrack if owntrack == None else owntrack
         calc_track = [i for i in self.conf.track_keys + self.conf.kml_keys + self.conf.csv_keys if i != owntrack]
         for tr in calc_track:
             self.rel_track[tr]=self.relativepoint_single(tr,owntrack)
+
+        calc_track = [i for i in self.conf.track_keys if i != owntrack]
+        for tr in calc_track:
+            for ottr in self.track[tr]['othertrack'].keys():
+                self.rel_track['@OT_{:s}@_{:s}'.format(tr,ottr)] = self.relativepoint_single(ottr,owntrack,parent_track=tr)
     def relativeradius(self,to_calc=None,owntrack=None):
         owntrack = self.conf.owntrack if owntrack == None else owntrack
-        calc_track = [i for i in self.conf.track_keys + self.conf.kml_keys + self.conf.csv_keys if i != owntrack] if to_calc == None else [to_calc]
+        if to_calc is None:
+            calc_track = self.get_trackkeys(owntrack)
+        else:
+            calc_track = to_calc
         for tr in calc_track:
             self.rel_track_radius[tr] = []
 
             # 注目軌道相対座標を線形補間する
             x_interp = np.linspace(min(self.rel_track[tr][:,0]),max(self.rel_track[tr][:,0]),int((max(self.rel_track[tr][:,0])-min(self.rel_track[tr][:,0]))/1.0)+1)
             f_xy = interpolate.interp1d(self.rel_track[tr][:,0],self.rel_track[tr][:,2])
             f_z  = interpolate.interp1d(self.rel_track[tr][:,0],self.rel_track[tr][:,3])
@@ -278,14 +391,22 @@
             self.rel_track_radius_cp[tr] = np.array(self.rel_track_radius_cp[tr])
     def plot2d(self, ax):
         if len(self.track) > 0:
             for i in self.conf.track_keys:
                 if self.track[i]['toshow']:
                     tmp = self.track[i]['result']
                     ax.plot(tmp[:,1],tmp[:,2],label=i,color=self.conf.track_data[i]['color'])
+                if len(self.track[i]['othertrack'])>0:
+                    for otkey in self.track[i]['othertrack'].keys():
+                        if self.track[i]['othertrack'][otkey]['toshow']:
+                            tmp = self.track[i]['othertrack'][otkey]['result']
+                            ax.plot(tmp[:,1],tmp[:,2],\
+                                    label='{:s}_{:s}'.format(i,otkey),\
+                                    color=self.track[i]['othertrack'][otkey]['color'],\
+                                    lw=1)
             #ax.invert_yaxis()
             #ax.set_aspect('equal')
             self.pointsequence_track.plot2d(ax)
         if self.generated_othertrack is not None:
             for otrack in self.generated_othertrack.keys():
                 if self.generated_othertrack[otrack]['toshow']:
                     tmp = self.generated_othertrack[otrack]['data']
@@ -374,14 +495,29 @@
             cp_dist.append(self.conf.track_data[trackkey]['endpoint'])
             cp_dist.append(0)
             if supplemental:
                 for dat in self.conf.track_data[trackkey]['supplemental_cp']: # supplemental_cpの追加
                     cp_dist.append(dat)
             cp_dist = sorted(set(cp_dist))
             pos_cp = self.track[trackkey]['result'][np.isin(self.track[trackkey]['result'][:,0],cp_dist)]
+        elif '@OT' in trackkey:
+            parent_key = re.search('(?<=@OT_).+(?=@)',trackkey).group(0)#trackkey.split('@')[1].split('OT_')[1]
+            child_key = trackkey.split('@_')[-1]
+            for dat in self.track[parent_key]['othertrack'][child_key]['tgen'].data:
+                if elem == None or dat['key'] == elem:
+                    cp_dist.append(dat['distance'])
+            cp_dist.append(0)
+
+            if supplemental:
+                parent_cp_dist,_ = self.takecp(parent_key) # 親軌道の制御点を求める
+                cp_dist = sorted(set(cp_dist + parent_cp_dist)) # 注目する軌道と親軌道の制御点の和集合を求める
+            else:
+                cp_dist = sorted(set(cp_dist))
+
+            pos_cp = self.track[parent_key]['othertrack'][child_key]['result'][np.isin(self.track[parent_key]['othertrack'][child_key]['result'][:,0],cp_dist)]
         else:
             for dat in self.pointsequence_track.track[trackkey]['result']:
                 cp_dist.append(dat[0])
             cp_dist.append(0)
             cp_dist = sorted(set(cp_dist))
             pos_cp = self.pointsequence_track.track[trackkey]['result'][np.isin(self.pointsequence_track.track[trackkey]['result'][:,0],cp_dist)]
         
@@ -420,15 +556,15 @@
             pdb.set_trace()
 
         self.relativepoint_all() # 全ての軌道データを自軌道基準の座標に変換
         self.relativeradius() # 全ての軌道データについて自軌道基準の相対曲率半径を算出
         cp_ownt,_  = self.takecp(self.conf.owntrack) # 自軌道の制御点距離程を抽出
 
         # owntrack以外の各軌道について処理する
-        for tr in [i for i in self.conf.track_keys + self.conf.kml_keys + self.conf.csv_keys if i != self.conf.owntrack]:
+        for tr in self.get_trackkeys(self.conf.owntrack):
             try:
                 _, pos_cp_tr = self.takecp(tr) # 注目している軌道の制御点座標データを抽出（注目軌道基準の座標）
                 relativecp = self.convert_relativecp(tr,pos_cp_tr) # 自軌道基準の距離程に変換
                 cp_tr_ownt = sorted(set([i for i in cp_ownt if i<=max(relativecp[:,3]) and i>min(relativecp[:,3])] + list(relativecp[:,3]))) # 自軌道制御点のうち注目軌道が含まれる点と、自軌道基準に変換した注目軌道距離程の和をとる
             #cp_tr_ownt = sorted(list(relativecp[:,3])) # 
             
                 self.relativeradius_cp(to_calc=tr,cp_dist=cp_tr_ownt) # 制御点毎の相対半径を算出
@@ -436,23 +572,23 @@
                 # too many indices for array: array is 1-dimensional, but 2 were indexed に対する処理
                 # = 自軌道基準の座標系で表せない軌道
                 print('{:s}: IndexError. Generate has been ignored.'.format(tr))
                 self.exclude_tracks.append(tr)
     
 
         # 他軌道構文生成
-        for tr in [i for i in self.conf.track_keys + self.conf.kml_keys + self.conf.csv_keys if (i != self.conf.owntrack and i not in self.exclude_tracks)]:
+        for tr in [i for i in self.get_trackkeys(self.conf.owntrack) if i not in self.exclude_tracks]:
             output_map = {'x':'', 'y':'', 'cant':'', 'center':'', 'interpolate_func':'', 'gauge':''}
             if self.conf.general['offset_variable'] is not None:
                 kp_val = '$'+self.conf.general['offset_variable']+' + '
             else:
                 kp_val = ''
 
             for data in self.rel_track_radius_cp[tr]:
-                if '@' not in tr or ('@' in tr and self.pointsequence_track.track[tr]['conf']['calc_relrad']):
+                if '@' not in tr or '@OT' in tr or (('@KML' in tr or '@CSV' in tr) and self.pointsequence_track.track[tr]['conf']['calc_relrad']):
                     output_map['x'] += '{:s}{:.2f};\n'.format(kp_val,data[0])
                     output_map['x'] += 'Track[\'{:s}\'].X.Interpolate({:.2f},{:.2f});\n'.format(tr,data[3],data[2])
                     output_map['y'] += '{:s}{:.2f};\n'.format(kp_val,data[0])
                     output_map['y'] += 'Track[\'{:s}\'].Y.Interpolate({:.2f},{:.2f});\n'.format(tr,data[6],data[5])
                 else:
                     output_map['x'] += '{:s}{:.2f};\n'.format(kp_val,data[0])
                     output_map['x'] += 'Track[\'{:s}\'].X.Interpolate({:.2f},{:.2f});\n'.format(tr,data[3],0)
@@ -472,15 +608,15 @@
                     output_map['cant'] += '{:s}{:.2f};\n'.format(kp_val,data[0])
                     output_map['cant'] += 'Track[\'{:s}\'].Cant.Interpolate({:.3f});\n'.format(tr,data[8])
                 '''
                 for data in self.convert_cant_with_relativecp(tr,relativecp['cant'][:,3]):
                     output_map['cant'] += '{:s}{:.2f};\n'.format(kp_val,data[0])
                     output_map['cant'] += 'Track[\'{:s}\'].Cant.Interpolate({:.3f});\n'.format(tr,data[1])
 
-
+            
             key = 'interpolate_func'
             if len(relativecp[key])>0:
                 for index in range(len(relativecp[key])):
                     output_map[key] += '{:s}{:.2f};\n'.format(kp_val,relativecp[key][index][3])
                     output_map[key] += 'Track[\'{:s}\'].Cant.SetFunction({:d});\n'.format(tr,int(pos_cp[key][index][7]))
             
             key = 'center'
@@ -512,14 +648,18 @@
             output_file += '# Track[\'{:s}\'].Cant.SetCenter\n'.format(tr)
             output_file += output_map['center']+'\n'
             output_file += '# Track[\'{:s}\'].Cant.SetGauge\n'.format(tr)
             output_file += output_map['gauge']+'\n'
 
             if '@' not in tr:
                 self.track[tr]['output_mapfile'] = output_file
+            elif '@OT' in tr:
+                parent_key = re.search('(?<=@OT_).+(?=@)',tr).group(0)
+                child_key = tr.split('@_')[-1]
+                self.track[parent_key]['othertrack'][child_key]['output_mapfile'] = output_file
             else:
                 self.pointsequence_track.track[tr]['conf']['output_mapfile'] = output_file
             
             #print(output_file)
             os.makedirs(self.conf.general['output_path'], exist_ok=True)
             f = open(self.conf.general['output_path'].joinpath(pathlib.Path('{:s}_converted.txt'.format(tr))),'w')
             f.write(output_file)
@@ -554,40 +694,54 @@
         for data in source:
             if data['key'] in ['radius', 'gradient', 'interpolate_func', 'cant', 'center', 'gauge']:
                 cplist[data['key']].append(data['distance'])
         return cplist
     def plot_symbols(self, ax, symboltype, size=20):
         ''' 制御点座標をプロットする
         '''
-        symbol_plot = {'radius':'o', 'gradient':'^', 'supplemental_cp':'x'}
+        symbol_plot = {'radius':'o', 'gradient':'^', 'supplemental_cp':'x', 'track':'+'}
         if len(self.track.keys()) > 0:
             for tr_l in self.conf.track_keys:
-                if self.track[tr_l]['toshow']:
+                if self.track[tr_l]['toshow'] and symboltype != 'track':
                     if symboltype == 'supplemental_cp':
                         pos = self.track[tr_l]['result'][np.isin(self.track[tr_l]['result'][:,0],self.conf.track_data[tr_l]['supplemental_cp'])]
                     else:
                         pos = self.track[tr_l]['result'][np.isin(self.track[tr_l]['result'][:,0],self.track[tr_l]['cplist_symbol'][symboltype])]
                     ax.scatter(pos[:,1],pos[:,2],color=self.conf.track_data[tr_l]['color'],marker=symbol_plot[symboltype],alpha=0.75,s=size)
+                elif symboltype == 'track':
+                    for tr_ot in self.track[tr_l]['othertrack'].keys():
+                        trackdata = self.track[tr_l]['othertrack'][tr_ot]
+                        if trackdata['toshow']:
+                            cp_dist = []
+                            for cp in trackdata['tgen'].data:
+                                cp_dist.append(cp['distance'])
+                            pos = trackdata['result'][np.isin(trackdata['result'][:,0],cp_dist)]
+                            ax.scatter(pos[:,1],pos[:,2],color=trackdata['color'],marker=symbol_plot[symboltype],alpha=0.75,s=size)
+                            
+                        
+                    
     def generate_otdata(self):
         ''' generate結果から他軌道座標データを生成する
         '''
         
         if False:
             import pdb
             pdb.set_trace()
 
         # generate結果をincludeする擬似マップファイルを生成
         output_file = ''
 
         # 自軌道ファイルをinclude
         path = self.conf.general['output_path'].joinpath(pathlib.Path('owntrack')).joinpath(self.conf.track_data[self.conf.general['owntrack']]['file'].name)
-        output_file += 'include \'{:s}\';\n'.format(str(path))
+        #output_file += 'include \'{:s}\';\n'.format(str(path))
+        output_file += self.read_owntrackmap(path)
 
         # 他軌道ファイルをinclude
-        for tr_l in [i for i in self.conf.track_keys + self.conf.kml_keys + self.conf.csv_keys if (i!= self.conf.general['owntrack'] and i not in self.exclude_tracks)]:
+        otlist = self.get_trackkeys(self.conf.general['owntrack'])
+        for tr_l in [i for i in otlist if (i not in self.exclude_tracks)]:
             path = self.conf.general['output_path'].joinpath(pathlib.Path('{:s}_converted.txt'.format(tr_l)))
             output_file += 'include \'{:s}\';\n'.format(str(path))
 
         otmap_path = self.conf.general['output_path'].joinpath(pathlib.Path('tmpmap.txt'))
 
         # kobushi-trackviewerのマップパーサーへoutput_fileを渡す
         ot_interp = mapinterpreter.ParseMap(env=None,parser=None)
@@ -618,7 +772,46 @@
         for key in self.ot_map_source.othertrack.data.keys():
             generator = trackgenerator.OtherTrackGenerator(self.ot_map_source,key)
             self.generated_othertrack[key]={'data':generator.generate(),\
                                             'toshow':True,\
                                             'color':'#000000',\
                                             #'controlpoints':[i['distance'] for i in self.ot_map_source.othertrack.data[key]],\
                                             'distrange':generator.distrange}
+    def get_trackkeys(self,owntrack):
+        calc_track = [i for i in self.conf.track_keys if i!=owntrack]
+        calc_track += self.conf.kml_keys
+        calc_track += self.conf.csv_keys
+
+        
+        for tr in [i for i in self.conf.track_keys if i != owntrack]:
+            for ottr in self.track[tr]['othertrack'].keys():
+                calc_track.append('@OT_{:s}@_{:s}'.format(tr,ottr))
+        return calc_track
+    def read_owntrackmap(self,filepath,rootpath = None):
+        mapdata = ''
+        input_path     = pathlib.Path(filepath)
+        #input_parent   = input_path.parent
+        #input_filename = input_path.name
+        if rootpath is None:
+            path = input_path
+        else:
+            path = pathlib.Path(rootpath).joinpath(input_path.name)
+        with open(path, mode='r') as fp:
+            mapdata = fp.read()
+        mapdata = re.sub('BveTs Map 2.02.*?\n', '', mapdata)
+
+        str_pointer = 0
+        result = ''
+        while(True):
+            m = re.search('include(\s)*\'.*\'(\s)*;',mapdata)
+            if m is None:
+                result += mapdata
+                break
+            else:
+                result += mapdata[:(m.span())[0]]
+                arg_include = re.search('(?<=include\s\').*?(?=\';)',m.group(0))
+                filepath = pathlib.Path(arg_include.group(0))
+                result += self.read_owntrackmap(filepath, rootpath=input_path.parent)
+                mapdata = mapdata[m.span()[1]:]
+        
+        return result
+
```

## tsutsuji/trackwindow.py

```diff
@@ -47,15 +47,15 @@
             self.master.protocol('WM_DELETE_WINDOW', self.closewindow)
 
             self.mainframe = ttk.Frame(self.master, padding='3 3 3 3')
             self.mainframe.columnconfigure(0,weight=1)
             self.mainframe.rowconfigure(0,weight=1)
             self.mainframe.grid(column=0, row=0,sticky=(tk.N, tk.W, tk.E, tk.S))
             self.master.geometry('+1100+0')
-            self.track_tree = CheckboxTreeview(self.mainframe, show='tree headings', columns=['linecolor'],selectmode='browse')
+            self.track_tree = CheckboxTreeview_tsutsuji(self.mainframe, show='tree headings', columns=['linecolor'],selectmode='browse')
             self.track_tree.bind("<ButtonRelease>", self.click_tracklist)
             self.track_tree.grid(column=0, row=0, sticky=(tk.N, tk.W, tk.E, tk.S))
             self.track_tree.column('#0', width=200)
             self.track_tree.column('linecolor', width=50)
             self.track_tree.heading('#0', text='track key')
             self.track_tree.heading('linecolor', text='Color')
 
@@ -70,52 +70,98 @@
         '''軌道リストをクリックしたときのイベント処理
         '''
         if event != None:
             clicked_column = self.track_tree.identify_column(event.x)
             clicked_track = self.track_tree.identify_row(event.y)
             clicked_track_rematt = re.sub('@OT_','',clicked_track)
             clicked_zone = getattr(event, 'widget').identify("element", event.x, event.y)
+            focused = self.track_tree.focus()
+            parent = self.track_tree.parent(focused)
             if clicked_zone == 'image': #チェックボックスをクリックしたか
-                if clicked_track == 'root': # rootをクリックした場合、cfgファイルから読み込んだ軌道を一括設定
-                    for tkey in self.mainwindow.trackcontrol.track.keys():
-                        self.mainwindow.trackcontrol.track[tkey]['toshow'] = False
-                    for tkey in self.track_tree.get_checked():
-                        if '@' not in tkey:
-                            self.mainwindow.trackcontrol.track[tkey]['toshow'] = True
-                elif clicked_track == 'seq_points': # seq_points をクリックした場合、kml/csvファイルから読み込んだ点列を一括設定
-                    for tkey in self.mainwindow.trackcontrol.pointsequence_track.track.keys():
-                        self.mainwindow.trackcontrol.pointsequence_track.track[tkey]['toshow'] = False
-                    for tkey in self.track_tree.get_checked():
-                        if '@KML_' in tkey or '@CSV_' in tkey:
-                            self.mainwindow.trackcontrol.pointsequence_track.track[tkey]['toshow'] = True
-                elif clicked_track == 'generated': # generatedをクリックした場合、計算した他軌道を一括設定
-                    for tkey in self.mainwindow.trackcontrol.generated_othertrack.keys():
-                        self.mainwindow.trackcontrol.generated_othertrack[tkey]['toshow'] = False
-                    for tkey in self.track_tree.get_checked():
-                        if '@OT_' in tkey:
-                            self.mainwindow.trackcontrol.generated_othertrack[re.sub('@OT_','',tkey)]['toshow'] = True
-                elif '@' not in clicked_track: # 個別のtrack(自軌道形式)をクリックした場合
-                    self.mainwindow.trackcontrol.track[clicked_track]['toshow'] = not self.mainwindow.trackcontrol.track[clicked_track]['toshow']
-                elif '@KML_' in clicked_track or '@CSV_' in clicked_track: # 個別のKML/CSV点列をクリックした場合
-                    self.mainwindow.trackcontrol.pointsequence_track.track[clicked_track]['toshow'] = not self.mainwindow.trackcontrol.pointsequence_track.track[clicked_track]['toshow']
-                else: # 個別の他軌道をクリックした場合
-                    self.mainwindow.trackcontrol.generated_othertrack[clicked_track_rematt]['toshow'] = not self.mainwindow.trackcontrol.generated_othertrack[clicked_track_rematt]['toshow']
+                # rootをクリックした場合、cfgファイルから読み込んだ軌道を一括設定
+                if clicked_track == 'root': 
+                    for tkey in self.track_tree.get_children('root'):
+                        target = self.mainwindow.trackcontrol.track[tkey]
+                        if self.track_tree.tag_has("checked", 'root'):
+                            target['toshow'] = True
+                        else:
+                            target['toshow'] = False
+                        for otkey in self.track_tree.get_children(tkey):
+                            ot_target = target['othertrack'][re.sub('@OT_','',otkey)]
+                            if self.track_tree.tag_has("checked", 'root'):
+                                ot_target['toshow'] = True
+                            else:
+                                ot_target['toshow'] = False
+                # seq_points をクリックした場合、kml/csvファイルから読み込んだ点列を一括設定
+                elif clicked_track == 'seq_points':
+                    for tkey in self.track_tree.get_children(clicked_track):
+                        target = self.mainwindow.trackcontrol.pointsequence_track.track[tkey]
+                        if self.track_tree.tag_has("checked", clicked_track):
+                            target['toshow'] = True
+                        else:
+                            target['toshow'] = False
+                # generatedをクリックした場合、計算した他軌道を一括設定
+                elif clicked_track == 'generated':
+                    for tkey in self.track_tree.get_children(clicked_track):
+                        target = self.mainwindow.trackcontrol.generated_othertrack[re.sub('@OT_','',tkey)]
+                        if self.track_tree.tag_has("checked", clicked_track):
+                            target['toshow'] = True
+                        else:
+                            target['toshow'] = False
+                # 個別のtrack(自軌道形式)をクリックした場合
+                elif parent == 'root':
+                    target = self.mainwindow.trackcontrol.track[clicked_track]
+                    if self.track_tree.tag_has("checked", clicked_track):
+                        target['toshow'] = True
+                    else:
+                        target['toshow'] = False
+                # 個別のKML/CSV点列をクリックした場合
+                elif parent == 'seq_points':
+                    target = self.mainwindow.trackcontrol.pointsequence_track.track[clicked_track]
+                    if self.track_tree.tag_has("checked", clicked_track):
+                        target['toshow'] = True
+                    else:
+                        target['toshow'] = False
+                # 自軌道に従属する他軌道をクリックした場合
+                elif '@OT_' in clicked_track: 
+                    clicked_track_rm = re.sub('@OT_','',focused)
+                    target = self.mainwindow.trackcontrol.track[self.track_tree.parent(focused)]['othertrack'][clicked_track_rm]
+                    if self.track_tree.tag_has("checked", focused):
+                        target['toshow'] = True
+                    else:
+                        target['toshow'] = False
+                # 個別の他軌道をクリックした場合
+                else:
+                    target = self.mainwindow.trackcontrol.generated_othertrack[clicked_track_rematt]
+                    if self.track_tree.tag_has("checked", focused):
+                        target['toshow'] = True
+                    else:
+                        target['toshow'] = False
             elif clicked_zone == 'text':
-                if clicked_column == '#1': #ラインカラーをクリックしたら、カラーピッカーを開く
+                #ラインカラーをクリックしたら、カラーピッカーを開く
+                if clicked_column == '#1': 
                     if '@' not in clicked_track:
                         nowcolor = self.mainwindow.trackcontrol.conf.track_data[clicked_track]['color']
+                    elif '@OT_' in clicked_track:
+                        clicked_track_rm = re.sub('@OT_','',focused)
+                        nowcolor = self.mainwindow.trackcontrol.track[parent]['othertrack'][clicked_track_rm]['color']
+                            
                     elif '@KML_' in clicked_track or '@CSV_' in clicked_track:
                         nowcolor = self.mainwindow.trackcontrol.pointsequence_track.track[clicked_track]['color']
                     else:
                         nowcolor = self.mainwindow.trackcontrol.generated_othertrack[clicked_track_rematt]['color']
                     inputdata = colorchooser.askcolor(color=nowcolor)
                     if inputdata[1] != None: # カラーピッカーでキャンセルされなかった場合、当該軌道に色を指定
                         if '@' not in clicked_track:
                             self.mainwindow.trackcontrol.conf.track_data[clicked_track]['color'] = inputdata[1]
                             self.track_tree.tag_configure(clicked_track,foreground=inputdata[1])
+                        elif '@OT_' in clicked_track: 
+                            clicked_track_rm = re.sub('@OT_','',focused)
+                            self.mainwindow.trackcontrol.track[parent]['othertrack'][clicked_track_rm]['color'] = inputdata[1]
+                            self.track_tree.tag_configure(clicked_track,foreground=inputdata[1])
                         elif '@KML_' in clicked_track or '@CSV_' in clicked_track:
                             self.mainwindow.trackcontrol.pointsequence_track.track[clicked_track]['color'] = inputdata[1]
                             self.track_tree.tag_configure(clicked_track,foreground=inputdata[1])
                         else:
                             self.mainwindow.trackcontrol.generated_othertrack[clicked_track_rematt]['color'] = inputdata[1]
                             self.track_tree.tag_configure(clicked_track,foreground=inputdata[1])
             self.mainwindow.drawall()
@@ -126,18 +172,26 @@
         if self.track_tree.exists('root'):
             self.track_tree.delete('root')
         self.track_tree.insert("", "end", 'root', text='root', open=True)
         colorix = 0
         for i in self.mainwindow.trackcontrol.track.keys():
             self.track_tree.insert("root", "end", i, text=i,\
                                    values=('■■■'),\
-                                   tags=(i,))
+                                   tags=(i,),\
+                                   open=True)
             self.track_tree.tag_configure(i,foreground=self.mainwindow.trackcontrol.conf.track_data[i]['color'])
             self.track_tree.change_state(i, 'checked' if self.mainwindow.trackcontrol.track[i]['toshow'] else 'unchecked')
 
+            # 従属する他軌道の表示
+            for otkey in self.mainwindow.trackcontrol.track[i]['othertrack'].keys():
+                self.track_tree.insert(i,"end",'@OT_'+otkey,text=otkey,values=('■■■'),\
+                                       tags=('@OT_'+otkey,))
+                self.track_tree.tag_configure('@OT_'+otkey,foreground=self.mainwindow.trackcontrol.track[i]['othertrack'][otkey]['color'])
+                self.track_tree.change_state('@OT_'+otkey, 'checked' if self.mainwindow.trackcontrol.track[i]['othertrack'][otkey]['toshow'] else 'unchecked')
+
         # KML/CSVから読み込んだ点列データの表示
         label_sqtr = 'seq_points'
         if self.track_tree.exists(label_sqtr):
             self.track_tree.delete(label_sqtr)
         self.track_tree.insert("", "end", label_sqtr, text=label_sqtr, open=True)
         for i in self.mainwindow.trackcontrol.pointsequence_track.track.keys():
             self.track_tree.insert(label_sqtr, "end", i, text=i,\
@@ -166,7 +220,15 @@
             self.set_treevalue()
     def closewindow(self):
         self.master.withdraw()
         self.master = None
     def sendtopmost(self,event=None):
         self.master.lift()
         self.master.focus_force()
+
+class CheckboxTreeview_tsutsuji(CheckboxTreeview):
+    ''' 子要素のチェックを全てon/offした場合に親要素のチェックを操作しないように変更
+    '''
+    def _check_ancestor(self, item):
+        self.change_state(item, "checked")
+    def _uncheck_ancestor(self, item):
+        self.change_state(item, "unchecked")
```

## Comparing `tsutsuji_trackcomputer-1.6.1.dist-info/LICENSE` & `tsutsuji_trackcomputer-1.7.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `tsutsuji_trackcomputer-1.6.1.dist-info/METADATA` & `tsutsuji_trackcomputer-1.7.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,19 +1,19 @@
 Metadata-Version: 2.1
 Name: tsutsuji-trackcomputer
-Version: 1.6.1
+Version: 1.7.0
 Summary: Track building helper for Bve trainsim 5/6
 Home-page: https://github.com/konawasabi/tsutsuji-trackcomputer/
 Author: Konawasabi
 Author-email: webmaster@konawasabi.riceball.jp
 License: Apache License 2.0
 Keywords: BVE trainsim
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: kobushi-trackviewer (>=1.1.4)
+Requires-Dist: kobushi-trackviewer (>=1.1.5)
 Requires-Dist: requests (>=2.28.1)
 
 # Tsutsuji TrackComputer
 
 Bve trainsim 5/6向けマップファイルの制作支援Pythonスクリプトです。
 全ての軌道を自軌道構文で記述し、一つの軌道を基準とした他軌道構文に変換するのが主な機能です。
 まだ開発途上ですが、軌道データ作成に役立つ測量機能も付属しています。
```

## Comparing `tsutsuji_trackcomputer-1.6.1.dist-info/RECORD` & `tsutsuji_trackcomputer-1.7.0.dist-info/RECORD`

 * *Files 23% similar despite different names*

```diff
@@ -1,21 +1,21 @@
 tsutsuji/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tsutsuji/__main__.py,sha256=7Gk_TYmLmfVa9AdkoLxZE8B46Qg3mou2ijm6dpmU8CM,647
-tsutsuji/_version.py,sha256=purtuLvskAhEdNLSjxoYqUibNFbOHk0IB5Wc4KCA7l4,22
+tsutsuji/_version.py,sha256=ZKj0X3okn4mK4HiX_1UKKuGOzcIskftLiHEMJogbUYY,22
 tsutsuji/backimg.py,sha256=T-ZX2URk12oOd6UUXCSqoZIZNyO1EO2ILHL_3r2aCjE,26323
 tsutsuji/config.py,sha256=cCqC_9R7D7SxvlGq4fGnNzbOAPQCMOfSYPGQLXfX2c4,5514
 tsutsuji/cui2.py,sha256=spk94smgq-bPZCFfT5wblgNY-o5Ir7mZ6Hx-7E9Zspw,2155
 tsutsuji/curvetrackplot.py,sha256=2XH3sqzdWKamAjDjdVb9xTfsZU0j24k7UUgew1HE9PQ,5753
-tsutsuji/drawcursor.py,sha256=1pmDNX4KFZx6-He3kGh5ONkYIxB-nabl2TiWLk-yocU,17026
-tsutsuji/gui_tsutsuji.py,sha256=76-f718L0JGYSO5W3DsY_fwR583cak_71zP6BVCzoT4,19787
+tsutsuji/drawcursor.py,sha256=ug8mm1FHxUTGW_-fAYh3vxqhnWz3DfkevtBkxwTABPk,19218
+tsutsuji/gui_tsutsuji.py,sha256=_nEjOGyiVV2YTmEc1Nju9m8hF4x1Ox7O5zpQzxJuRIU,19805
 tsutsuji/kml2track.py,sha256=uJtPMpgi3t2ljZhUkyWj2B2j6jAB3h_tHjwfaFfoDQs,5060
 tsutsuji/kp_offset.py,sha256=IcWVmcs_TRVlAI1xbyACaYqfWd3Stt4WCTbSpPibJ9w,6311
 tsutsuji/math.py,sha256=m-BN4gritBsqiAcfJTp4G3sXCrGcY2IemHCiZlNLDgQ,13102
-tsutsuji/measure.py,sha256=1oCB2nuzpg3CGVUbqlQYr7NygsYlBofuBNMHVNyh7gs,28724
+tsutsuji/measure.py,sha256=rl1Sq7nK35SNFE9nuuanHOi1R1v3c99-8dMJt2pISBw,29828
 tsutsuji/solver.py,sha256=Sa4eM5MAIUbsCdQ8AJ_tf7plzkLoIN1wX6ktDZSVS5k,69046
-tsutsuji/track_control.py,sha256=Dqu3Hqtg-X2BbRY1zYRYAI0CpM0iautPfcfUYmq5QR8,35058
-tsutsuji/trackwindow.py,sha256=c2c1bsR2AIwqWCEwjPVnMkwLWgJbjpng8Xpso6pHhzU,10318
-tsutsuji_trackcomputer-1.6.1.dist-info/LICENSE,sha256=F1Ts-WBWMCb_LIZ9VTntNMKH8rjOlcBwWWGRItqwCrs,9723
-tsutsuji_trackcomputer-1.6.1.dist-info/METADATA,sha256=GJTKixkEW7lV66-qLona3IINsPngXa23v8yR15Irh4M,3468
-tsutsuji_trackcomputer-1.6.1.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
-tsutsuji_trackcomputer-1.6.1.dist-info/top_level.txt,sha256=-4EP2VNLqJy2zJugsOEOF9q-Ir7baVH8QYXuuNtm_0s,9
-tsutsuji_trackcomputer-1.6.1.dist-info/RECORD,,
+tsutsuji/track_control.py,sha256=eaAKcPlu7wtWaoEgo_-PK8LPQrh32h5QSC5T8_y-618,45810
+tsutsuji/trackwindow.py,sha256=tZhteTuMdOqf2CyKCUSGh8oDbp6sgRkOHsV9Z8yC_gM,13273
+tsutsuji_trackcomputer-1.7.0.dist-info/LICENSE,sha256=F1Ts-WBWMCb_LIZ9VTntNMKH8rjOlcBwWWGRItqwCrs,9723
+tsutsuji_trackcomputer-1.7.0.dist-info/METADATA,sha256=kwfmyMfqdDJ-zm5pbsCPkZNTW1f6LBji17W1ptGrc2w,3468
+tsutsuji_trackcomputer-1.7.0.dist-info/WHEEL,sha256=pkctZYzUS4AYVn6dJ-7367OJZivF2e8RA9b_ZBjif18,92
+tsutsuji_trackcomputer-1.7.0.dist-info/top_level.txt,sha256=-4EP2VNLqJy2zJugsOEOF9q-Ir7baVH8QYXuuNtm_0s,9
+tsutsuji_trackcomputer-1.7.0.dist-info/RECORD,,
```

